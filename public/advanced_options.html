<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Options Trading Analyzer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
            padding: 10px;
            max-width: 100%;
            box-sizing: border-box;
        }
        h1 {
            font-size: 1.5em;
            text-align: center;
        }
        p {
            font-size: 1em;
        }
        input, button, select {
            width: 100%;
            max-width: 300px;
            padding: 10px;
            margin: 5px 0;
            font-size: 1em;
            box-sizing: border-box;
        }
        button {
            background-color: #4BC0C0;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #3aa0a0;
        }
        #output, #lookupResults {
            margin-top: 10px;
            font-size: 0.9em;
        }
        .ticker-option {
            cursor: pointer;
            padding: 5px;
            border-bottom: 1px solid #ddd;
        }
        .ticker-option:hover {
            background-color: #f0f0f0;
        }
        nav {
            margin: 10px 0;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left: 4px solid #4BC0C0;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 600px) {
            h1 {
                font-size: 1.2em;
            }
            p, #output, #lookupResults, ul {
                font-size: 0.85em;
            }
            input, button, select {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html"><button>Price Prediction App</button></a>
    </nav>
    <h1>Advanced Options Trading Analyzer</h1>
    <p>Enter ticker (e.g., ^SPX, ^XSP, AAPL, TSLA), select expiration, spread type, and analyze spreads with $0.05 slippage, EV > $1, R/R > 100%, POP > 55%.</p>
    <input type="text" id="ticker" placeholder="Ticker (e.g., ^SPX, ^XSP, AAPL, TSLA)" value="^SPX" />
    <button onclick="lookupTicker()">Lookup Ticker</button>
    <div id="lookupResults"></div>
    <select id="expiration">
        <option value="">Select expiration date</option>
    </select>
    <select id="spreadType">
        <option value="call">Vertical Call Credit Spread</option>
        <option value="put">Vertical Put Credit Spread</option>
    </select>
    <button onclick="analyzeSpreads()">Analyze Spreads</button>
    <div id="output"></div>

    <script>
        const API_BASE_URL = 'http://localhost:3000/api';

        function normCdf(x) {
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            let prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            if (x > 0) prob = 1 - prob;
            return prob;
        }

        function blackScholesDelta(S, K, T, r, sigma, type = 'call') {
            if (T <= 0 || sigma <= 0) return 0.5;
            const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
            if (type === 'call') {
                return normCdf(d1);
            } else {
                return normCdf(d1) - 1;
            }
        }

        async function lookupTicker() {
            const ticker = document.getElementById('ticker').value.trim().toUpperCase().replace(/[^A-Z0-9^]/g, '');
            const lookupResults = document.getElementById('lookupResults');
            lookupResults.innerHTML = '<div class="spinner"></div>';

            if (!ticker) {
                lookupResults.innerHTML = '<p>Please enter a ticker to search.</p>';
                return;
            }

            try {
                const quoteResponse = await fetchWithRetry(`${API_BASE_URL}/tradestation/quote/${ticker}`);
                const quoteData = await quoteResponse.json();
                let results = [];

                if (quoteData.Quotes && quoteData.Quotes.length > 0) {
                    const optionsResponse = await fetchWithRetry(`${API_BASE_URL}/tradestation/options/${ticker}`);
                    const optionsData = await optionsResponse.json();
                    if (optionsData.Expirations && optionsData.Expirations.length > 0) {
                        results.push({
                            ticker: ticker,
                            name: quoteData.Quotes[0].Description || `Unknown (${ticker})`,
                            type: 'Options'
                        });
                    }
                }

                if (results.length === 0) {
                    lookupResults.innerHTML = `<p>No options chain found for "${ticker}". Try ^SPX, ^XSP, AAPL, or TSLA.</p>`;
                    return;
                }

                lookupResults.innerHTML = `
                    <p><strong>Search Results for "${ticker}":</strong></p>
                    <ul>
                        ${results.map(r => `
                            <li class="ticker-option" onclick="selectTicker('${r.ticker}')">
                                ${r.ticker} - ${r.name} (${r.type})
                            </li>
                        `).join('')}
                    </ul>
                `;
                if (results.length > 0) {
                    fetchExpirations(ticker);
                }
            } catch (error) {
                lookupResults.innerHTML = `<p>Error searching ticker: ${error.message}. Ensure server is running (http://localhost:3000) and TradeStation access token is valid.</p>`;
            }
        }

        function selectTicker(ticker) {
            document.getElementById('ticker').value = ticker;
            document.getElementById('lookupResults').innerHTML = '';
            fetchExpirations(ticker);
        }

        async function fetchExpirations(ticker) {
            const expirationSelect = document.getElementById('expiration');
            expirationSelect.innerHTML = '<option value="">Loading expirations...</option>';

            try {
                const response = await fetchWithRetry(`${API_BASE_URL}/tradestation/options/${ticker}`);
                const data = await response.json();
                if (!data.Expirations || !data.Expirations.length) {
                    expirationSelect.innerHTML = '<option value="">No expirations found</option>';
                    return;
                }

                const expirations = data.Expirations.map(exp => exp.ExpirationDate);
                if (expirations.length === 0) {
                    expirationSelect.innerHTML = '<option value="">No expirations available</option>';
                    return;
                }

                expirationSelect.innerHTML = '<option value="">Select expiration date</option>' + 
                    expirations.map(exp => `<option value="${exp}">${exp}</option>`).join('');
            } catch (error) {
                expirationSelect.innerHTML = `<option value="">Error loading expirations: ${error.message}. Ensure server is running and TradeStation access token is valid.</option>`;
            }
        }

        async function analyzeSpreads() {
            const ticker = document.getElementById('ticker').value.trim();
            const expiration = document.getElementById('expiration').value;
            const spreadType = document.getElementById('spreadType').value;

            if (!ticker || !expiration) {
                alert('Please enter ticker and select an expiration date.');
                return;
            }

            const output = document.getElementById('output');
            output.innerHTML = '<div class="spinner"></div>';

            try {
                const quoteResponse = await fetchWithRetry(`${API_BASE_URL}/tradestation/quote/${ticker}`);
                const quoteData = await quoteResponse.json();
                if (!quoteData.Quotes || !quoteData.Quotes.length) {
                    throw new Error('Unable to fetch underlying price.');
                }
                const S = parseFloat(quoteData.Quotes[0].Last); // Underlying price

                const optionsResponse = await fetchWithRetry(`${API_BASE_URL}/tradestation/options/${ticker}?expiration=${expiration}`);
                const optionsData = await optionsResponse.json();
                if (!optionsData.Options || !optionsData.Options.length) {
                    throw new Error('No options data found for this ticker and expiration.');
                }

                const options = optionsData.Options;
                const calls = options.filter(opt => opt.OptionType === 'Call');
                const puts = options.filter(opt => opt.OptionType === 'Put');

                const chain = spreadType === 'call' ? calls : puts;

                if (chain.length === 0) {
                    throw new Error(`No ${spreadType} options found for this expiration.`);
                }

                const r = 0.05; // Risk-free rate assumption
                const today = new Date();
                const expDate = new Date(expiration);
                const T = (expDate - today) / (1000 * 60 * 60 * 24 * 365); // Time to expiration in years

                const profitableSpreads = [];
                for (let i = 0; i < chain.length - 1; i++) {
                    const shortOption = chain[i];
                    for (let j = i + 1; j < chain.length; j++) {
                        const longOption = chain[j];

                        if (spreadType === 'call' && shortOption.StrikePrice >= longOption.StrikePrice) continue;
                        if (spreadType === 'put' && shortOption.StrikePrice <= longOption.StrikePrice) continue;

                        const shortMid = (shortOption.Bid + shortOption.Ask) / 2;
                        const longMid = (longOption.Bid + longOption.Ask) / 2;
                        let credit = shortMid - longMid - 0.05; // Slippage adjustment
                        if (credit <= 0) continue;

                        const width = Math.abs(shortOption.StrikePrice - longOption.StrikePrice);
                        const maxLoss = width - credit;
                        if (maxLoss <= 0) continue;

                        const riskReward = credit / maxLoss;
                        if (riskReward <= 1) continue; // R/R > 100%

                        const sigma = shortOption.ImpliedVolatility || 0.2; // Fallback IV
                        const shortDelta = blackScholesDelta(S, shortOption.StrikePrice, T, r, sigma, spreadType);
                        const pop = spreadType === 'call' ? 1 - shortDelta : -shortDelta;
                        if (pop <= 0.55) continue; // POP > 55%

                        const ev = pop * credit + (1 - pop) * (-maxLoss);
                        if (ev <= 1) continue; // EV > $1

                        profitableSpreads.push({
                            shortStrike: shortOption.StrikePrice,
                            longStrike: longOption.StrikePrice,
                            credit: credit.toFixed(2),
                            maxLoss: maxLoss.toFixed(2),
                            riskReward: (riskReward * 100).toFixed(2) + '%',
                            ev: ev.toFixed(2),
                            pop: (pop * 100).toFixed(2) + '%'
                        });
                    }
                }

                if (profitableSpreads.length === 0) {
                    output.innerHTML = `<p>No profitable vertical ${spreadType} spreads found for ${ticker} matching criteria (EV > $1, R/R > 100%, POP > 55%). Try a different ticker (e.g., ^SPX, ^XSP, AAPL, TSLA) or expiration.</p>`;
                } else {
                    output.innerHTML = `
                        <h2>Profitable Vertical ${spreadType.toUpperCase()} Credit Spreads for ${ticker}</h2>
                        <p>Expiration: ${expiration}</p>
                        <ul>
                            ${profitableSpreads.map(spread => `
                                <li>
                                    Short Strike: ${spread.shortStrike}, Long Strike: ${spread.longStrike}<br>
                                    Credit (with $0.05 slippage): $${spread.credit}, Max Loss: $${spread.maxLoss}<br>
                                    Risk/Reward: ${spread.riskReward}, EV: $${spread.ev}, POP: ${spread.pop}
                                </li>
                            `).join('')}
                        </ul>
                    `;
                }
            } catch (error) {
                output.innerHTML = `<p>Error: ${error.message}. Ensure server is running (http://localhost:3000) and TradeStation access token is valid. Try ^SPX, ^XSP, AAPL, or TSLA.</p>`;
            }
        }

        async function fetchWithRetry(url, retries = 5, delay = 3000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (response.status === 429 || response.status === 403) {
                        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                        continue;
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === retries - 1) throw error;
                }
            }
        }

        window.onload = () => fetchExpirations('^SPX');
    </script>
</body>
</html>